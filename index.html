<!DOCTYPE html>
<html lang="es">
  <head>
    <meta charset="UTF-8" />
    <meta
      name="viewport"
      content="width=device-width, initial-scale=1.0"
    />
    <title> Dragon's Gold Heist - Babylon.js</title>
    <link
      rel="stylesheet"
      href="./src/css/styles.css"
    />
    <script src="https://cdn.babylonjs.com/babylon.js"></script>
    <script src="https://cdn.babylonjs.com/loaders/babylonjs.loaders.min.js"></script>
  </head>
  <body>
    <canvas id="renderCanvas"></canvas>

    <div id="ui-overlay">
      <h1> Dragon's Gold Heist</h1>
      <p>
         Monedas en Cueva: <span id="coins-delivered">0</span> /
        <span id="total-coins">5</span>
      </p>
      <p>
        <span
          class="status-indicator"
          id="status-light"
        ></span>
        Estado: <span id="status-text">Sin moneda</span>
      </p>
    </div>

    <div id="instructions">
      <h3> Controles</h3>
      <p> WASD - Mover drag贸n</p>
      <p>锔 ESPACIO - Recoger/Dejar moneda</p>
      <p> Objetivo: Lleva todas las monedas a la cueva</p>
    </div>

    <div id="victory-screen">
      <h2> 隆Victoria! </h2>
      <p>隆Has completado tu tesoro!</p>
      <p>Todas las monedas est谩n en tu cueva</p>
    </div>

    <script>
      // ============================================
      // CONFIGURACIN INICIAL
      // ============================================
      const canvas = document.getElementById('renderCanvas');
      const engine = new BABYLON.Engine(canvas, true);

      // Variables de estado del juego
      let monedaEnMano = false;
      let monedasEntregadas = 0;
      const TOTAL_MONEDAS = 5;
      let inputMap = {};
      let monedaActual = null;

      // ============================================
      // FUNCIN PARA CREAR TEXTURAS PROCEDURALES
      // ============================================
      function crearTexturaProceduralEscamas(scene) {
        const textura = new BABYLON.DynamicTexture(
          'dragon-texture',
          512,
          scene
        );
        const ctx = textura.getContext();

        // Fondo verde oscuro (piel de drag贸n)
        ctx.fillStyle = '#2d5016';
        ctx.fillRect(0, 0, 512, 512);

        // Dibujar escamas
        for (let y = 0; y < 512; y += 30) {
          for (let x = 0; x < 512; x += 30) {
            const offset = (y / 30) % 2 === 0 ? 15 : 0;
            ctx.fillStyle = '#3a6b1f';
            ctx.beginPath();
            ctx.arc(x + offset, y, 12, 0, Math.PI * 2);
            ctx.fill();

            ctx.fillStyle = '#4d8a28';
            ctx.beginPath();
            ctx.arc(x + offset, y, 8, 0, Math.PI * 2);
            ctx.fill();
          }
        }

        textura.update();
        return textura;
      }

      function crearTexturaMoneda(scene) {
        const textura = new BABYLON.DynamicTexture('coin-texture', 256, scene);
        const ctx = textura.getContext();

        // Gradiente dorado
        const gradient = ctx.createRadialGradient(128, 128, 20, 128, 128, 128);
        gradient.addColorStop(0, '#FFD700');
        gradient.addColorStop(0.5, '#FFA500');
        gradient.addColorStop(1, '#FF8C00');

        ctx.fillStyle = gradient;
        ctx.fillRect(0, 0, 256, 256);

        // Detalles de la moneda
        ctx.strokeStyle = '#B8860B';
        ctx.lineWidth = 4;
        ctx.beginPath();
        ctx.arc(128, 128, 100, 0, Math.PI * 2);
        ctx.stroke();

        ctx.beginPath();
        ctx.arc(128, 128, 80, 0, Math.PI * 2);
        ctx.stroke();

        textura.update();
        return textura;
      }

      function crearTexturaPiedra(scene) {
        const textura = new BABYLON.DynamicTexture('stone-texture', 512, scene);
        const ctx = textura.getContext();

        ctx.fillStyle = '#696969';
        ctx.fillRect(0, 0, 512, 512);

        // Agregar ruido para efecto de piedra
        for (let i = 0; i < 2000; i++) {
          const x = Math.random() * 512;
          const y = Math.random() * 512;
          const size = Math.random() * 3;
          const gray = Math.floor(Math.random() * 100 + 100);
          ctx.fillStyle = `rgb(${gray}, ${gray}, ${gray})`;
          ctx.fillRect(x, y, size, size);
        }

        textura.update();
        return textura;
      }

      function crearTexturaHierba(scene) {
        const textura = new BABYLON.DynamicTexture('grass-texture', 512, scene);
        const ctx = textura.getContext();

        ctx.fillStyle = '#567d46';
        ctx.fillRect(0, 0, 512, 512);

        // Agregar variaci贸n de hierba
        for (let i = 0; i < 3000; i++) {
          const x = Math.random() * 512;
          const y = Math.random() * 512;
          const green = Math.floor(Math.random() * 50 + 80);
          ctx.fillStyle = `rgb(${green - 30}, ${green}, ${green - 50})`;
          ctx.fillRect(x, y, 1, Math.random() * 3 + 1);
        }

        textura.update();
        return textura;
      }

      // ============================================
      // CREACIN DE LA ESCENA
      // ============================================
      const createScene = function () {
        const scene = new BABYLON.Scene(engine);
        scene.collisionsEnabled = true;

        // ============================================
        // SKYBOX MEDIEVAL
        // ============================================
        const skybox = BABYLON.MeshBuilder.CreateBox(
          'skyBox',
          { size: 1000.0 },
          scene
        );
        const skyboxMaterial = new BABYLON.StandardMaterial('skyBox', scene);
        skyboxMaterial.backFaceCulling = false;
        skyboxMaterial.reflectionTexture = new BABYLON.CubeTexture(
          'https://playground.babylonjs.com/textures/skybox',
          scene
        );
        skyboxMaterial.reflectionTexture.coordinatesMode =
          BABYLON.Texture.SKYBOX_MODE;
        skyboxMaterial.diffuseColor = new BABYLON.Color3(0, 0, 0);
        skyboxMaterial.specularColor = new BABYLON.Color3(0, 0, 0);
        skybox.material = skyboxMaterial;

        // ============================================
        // CMARA Y LUZ
        // ============================================
        const camera = new BABYLON.ArcRotateCamera(
          'camera',
          -Math.PI / 2,
          Math.PI / 3,
          30,
          BABYLON.Vector3.Zero(),
          scene
        );
        camera.attachControl(canvas, true);
        camera.lowerRadiusLimit = 15;
        camera.upperRadiusLimit = 50;

        const light = new BABYLON.HemisphericLight(
          'light',
          new BABYLON.Vector3(0, 1, 0),
          scene
        );
        light.intensity = 1.2;

        const directionalLight = new BABYLON.DirectionalLight(
          'dirLight',
          new BABYLON.Vector3(-1, -2, -1),
          scene
        );
        directionalLight.intensity = 0.5;

        // ============================================
        // MATERIALES
        // ============================================
        const matDragon = new BABYLON.StandardMaterial('matDragon', scene);
        matDragon.diffuseTexture = crearTexturaProceduralEscamas(scene);
        matDragon.specularColor = new BABYLON.Color3(0.2, 0.3, 0.1);

        const matMoneda = new BABYLON.StandardMaterial('matMoneda', scene);
        matMoneda.diffuseTexture = crearTexturaMoneda(scene);
        matMoneda.specularColor = new BABYLON.Color3(1, 0.8, 0);
        matMoneda.emissiveColor = new BABYLON.Color3(0.2, 0.15, 0);

        const matCueva = new BABYLON.StandardMaterial('matCueva', scene);
        matCueva.diffuseTexture = crearTexturaPiedra(scene);
        matCueva.diffuseColor = new BABYLON.Color3(0.3, 0.2, 0.1);

        const matPueblo = new BABYLON.StandardMaterial('matPueblo', scene);
        matPueblo.diffuseTexture = crearTexturaHierba(scene);

        // ============================================
        // CREAR SUELO PRINCIPAL CON TEXTURA MEDIEVAL
        // ============================================
        const matSuelo = new BABYLON.StandardMaterial('matSuelo', scene);
        // Textura de tierra/piedra medieval desde URL
        const sueloTexture = new BABYLON.Texture(
          'https://raw.githubusercontent.com/BabylonJS/Assets/master/textures/ground.jpg',
          scene
        );
        sueloTexture.uScale = 10;
        sueloTexture.vScale = 10;
        matSuelo.diffuseTexture = sueloTexture;
        matSuelo.specularColor = new BABYLON.Color3(0.1, 0.1, 0.1);

        const suelo = BABYLON.MeshBuilder.CreateGround(
          'suelo',
          { width: 50, height: 50, subdivisions: 10 },
          scene
        );
        suelo.material = matSuelo;
        suelo.receiveShadows = true;

        // ============================================
        // CREAR DRAGN (JUGADOR) - MODELO GLTF
        // ============================================
        let dragon = null;
        let dragonMesh = null;

        // Cargar el modelo GLTF del drag贸n
        BABYLON.SceneLoader.ImportMesh(
          '',
          './src/assets/models/',
          'Dragon.gltf',
          scene,
          function (meshes) {
            // El modelo cargado
            dragonMesh = meshes[0];

            // Crear un contenedor padre para controlar el drag贸n
            dragon = new BABYLON.TransformNode('dragonController');
            dragonMesh.parent = dragon;

            // Ajustar escala del modelo (puede variar seg煤n el modelo)
            dragonMesh.scaling = new BABYLON.Vector3(0.5, 0.5, 0.5);

            // Ajustar posici贸n del modelo respecto al contenedor
            dragonMesh.position = new BABYLON.Vector3(0, 0, 0);

            // Sin rotaci贸n inicial - el modelo ya debe estar orientado correctamente
            dragonMesh.rotation.y = 0;

            // Posici贸n inicial del drag贸n en la escena
            dragon.position = new BABYLON.Vector3(0, 0, 0);

            console.log(' Modelo de drag贸n cargado exitosamente');
          }
        );

        // ============================================
        // CREAR ZONA DE LA CUEVA (Zona de Entrega)
        // ============================================

        // Material para paredes de cueva
        const matParedCueva = new BABYLON.StandardMaterial(
          'matParedCueva',
          scene
        );
        matParedCueva.diffuseColor = new BABYLON.Color3(0.3, 0.25, 0.2);
        matParedCueva.specularColor = new BABYLON.Color3(0.1, 0.1, 0.1);

        // Crear textura de roca para las paredes
        const rocaTexture = new BABYLON.Texture(
          'https://raw.githubusercontent.com/BabylonJS/Assets/master/textures/rock.png',
          scene
        );
        matParedCueva.diffuseTexture = rocaTexture;
        matParedCueva.bumpTexture = rocaTexture;

        // Funci贸n para crear pared de cueva con forma irregular
        const crearParedCueva = (posicion, rotacion, nombre) => {
          // Pared principal
          const pared = BABYLON.MeshBuilder.CreateBox(
            nombre,
            { width: 10, height: 5, depth: 1 },
            scene
          );
          pared.material = matParedCueva;
          pared.position = posicion;
          pared.rotation.y = rotacion;

          // Agregar protuberancias de roca para efecto irregular
          for (let i = 0; i < 8; i++) {
            const roca = BABYLON.MeshBuilder.CreateSphere(
              `${nombre}_roca${i}`,
              { diameter: Math.random() * 2 + 1 },
              scene
            );
            roca.material = matParedCueva;
            roca.position = new BABYLON.Vector3(
              posicion.x + (Math.random() - 0.5) * 8,
              Math.random() * 4 + 0.5,
              posicion.z + (Math.random() - 0.5) * 2
            );
            roca.scaling.y = 0.6;
          }

          return pared;
        };

        // Crear las 4 paredes de la cueva formando un semic铆rculo
        crearParedCueva(new BABYLON.Vector3(-18, 2.5, -20), 0, 'paredCuevaA'); // Pared trasera
        crearParedCueva(
          new BABYLON.Vector3(-23, 2.5, -15),
          Math.PI / 2,
          'paredCuevaB'
        ); // Pared izquierda
        crearParedCueva(
          new BABYLON.Vector3(-13, 2.5, -15),
          -Math.PI / 2,
          'paredCuevaD'
        ); // Pared derecha

        // Techo de la cueva
        const techoCueva = BABYLON.MeshBuilder.CreateBox(
          'techoCueva',
          { width: 12, height: 1, depth: 12 },
          scene
        );
        techoCueva.material = matParedCueva;
        techoCueva.position = new BABYLON.Vector3(-18, 5.5, -15);

        // Agregar estalactitas
        for (let i = 0; i < 5; i++) {
          const estalactita = BABYLON.MeshBuilder.CreateCylinder(
            `estalactita${i}`,
            {
              height: Math.random() * 2 + 1,
              diameterTop: 0.3,
              diameterBottom: 0.1,
            },
            scene
          );
          estalactita.material = matParedCueva;
          estalactita.position = new BABYLON.Vector3(
            -18 + (Math.random() - 0.5) * 8,
            5,
            -15 + (Math.random() - 0.5) * 8
          );
        }

        // Saco de monedas (Bag_Coins) - Zona de entrega visual
        const matSaco = new BABYLON.StandardMaterial('matSaco', scene);
        matSaco.diffuseColor = new BABYLON.Color3(0.6, 0.4, 0.2);

        const matCuerdaSaco = new BABYLON.StandardMaterial(
          'matCuerdaSaco',
          scene
        );
        matCuerdaSaco.diffuseColor = new BABYLON.Color3(0.8, 0.7, 0.3);

        // Crear saco principal
        const saco = BABYLON.MeshBuilder.CreateSphere(
          'saco',
          { diameter: 1.5, segments: 16 },
          scene
        );
        saco.material = matSaco;
        saco.scaling.y = 1.2;
        saco.position = new BABYLON.Vector3(-18, 0.7, -15);

        // Parte superior del saco (atado)
        const cuelloBolsa = BABYLON.MeshBuilder.CreateCylinder(
          'cuelloBolsa',
          { height: 0.3, diameter: 0.8, diameterTop: 0.5 },
          scene
        );
        cuelloBolsa.material = matSaco;
        cuelloBolsa.position = new BABYLON.Vector3(-18, 1.5, -15);

        // Cuerda del saco
        const cuerda = BABYLON.MeshBuilder.CreateTorus(
          'cuerda',
          { diameter: 0.7, thickness: 0.08 },
          scene
        );
        cuerda.material = matCuerdaSaco;
        cuerda.position = new BABYLON.Vector3(-18, 1.5, -15);
        cuerda.rotation.x = Math.PI / 2;

        // Zona de entrega (invisible para detecci贸n)
        const zonaEntrega = BABYLON.MeshBuilder.CreateGround(
          'zonaEntrega',
          { width: 4, height: 4 },
          scene
        );
        const matZonaEntrega = new BABYLON.StandardMaterial(
          'matZonaEntrega',
          scene
        );
        matZonaEntrega.diffuseColor = new BABYLON.Color3(0.5, 0, 0);
        matZonaEntrega.alpha = 0.2;
        matZonaEntrega.emissiveColor = new BABYLON.Color3(0.3, 0, 0);
        zonaEntrega.material = matZonaEntrega;
        zonaEntrega.position = new BABYLON.Vector3(-18, 0.05, -15);

        // ============================================
        // CREAR ZONA DEL PUEBLO (Zona de Recogida)
        // ============================================
        const zonaPueblo = BABYLON.MeshBuilder.CreateGround(
          'zonaPueblo',
          { width: 12, height: 12 },
          scene
        );
        zonaPueblo.material = matPueblo;
        zonaPueblo.position = new BABYLON.Vector3(15, 0.02, 15);

        // Casitas del pueblo
        const matCasa = new BABYLON.StandardMaterial('matCasa', scene);
        matCasa.diffuseColor = new BABYLON.Color3(0.8, 0.6, 0.4);

        const matTecho = new BABYLON.StandardMaterial('matTecho', scene);
        matTecho.diffuseColor = new BABYLON.Color3(0.6, 0.2, 0.1);

        for (let i = 0; i < 3; i++) {
          const casa = BABYLON.MeshBuilder.CreateBox(
            `casa${i}`,
            { width: 3, height: 3, depth: 3 },
            scene
          );
          casa.material = matCasa;
          casa.position = new BABYLON.Vector3(12 + i * 4, 1.5, 12 + i * 2);

          const techo = BABYLON.MeshBuilder.CreateCylinder(
            `techo${i}`,
            {
              height: 2,
              diameterTop: 0,
              diameterBottom: 4,
            },
            scene
          );
          techo.material = matTecho;
          techo.position = new BABYLON.Vector3(12 + i * 4, 4, 12 + i * 2);
        }

        // ============================================
        // CREAR ELEMENTOS DECORATIVOS PROCEDURALES
        // ============================================

        // Materiales para decoraciones
        const matMadera = new BABYLON.StandardMaterial('matMadera', scene);
        matMadera.diffuseColor = new BABYLON.Color3(0.4, 0.25, 0.1);

        const matOro = new BABYLON.StandardMaterial('matOro', scene);
        matOro.diffuseColor = new BABYLON.Color3(1, 0.84, 0);
        matOro.specularColor = new BABYLON.Color3(1, 0.9, 0.3);
        matOro.emissiveColor = new BABYLON.Color3(0.3, 0.25, 0);

        const matPiedraOscura = new BABYLON.StandardMaterial(
          'matPiedraOscura',
          scene
        );
        matPiedraOscura.diffuseColor = new BABYLON.Color3(0.2, 0.2, 0.2);

        const matFuego = new BABYLON.StandardMaterial('matFuego', scene);
        matFuego.diffuseColor = new BABYLON.Color3(1, 0.5, 0);
        matFuego.emissiveColor = new BABYLON.Color3(1, 0.3, 0);

        // Antorchas en la cueva
        const crearAntorcha = (pos) => {
          const palo = BABYLON.MeshBuilder.CreateCylinder(
            'paloAntorcha',
            { height: 2, diameter: 0.1 },
            scene
          );
          palo.material = matMadera;
          palo.position = new BABYLON.Vector3(pos.x, 1, pos.z);

          const fuego = BABYLON.MeshBuilder.CreateSphere(
            'fuego',
            { diameter: 0.3 },
            scene
          );
          fuego.material = matFuego;
          fuego.position = new BABYLON.Vector3(pos.x, 2.2, pos.z);
        };

        crearAntorcha(new BABYLON.Vector3(-15, 0, -12));
        crearAntorcha(new BABYLON.Vector3(-21, 0, -12));

        // Barriles en el pueblo
        const crearBarril = (pos) => {
          const barril = BABYLON.MeshBuilder.CreateCylinder(
            'barril',
            { height: 1.2, diameter: 0.8 },
            scene
          );
          barril.material = matMadera;
          barril.position = new BABYLON.Vector3(pos.x, 0.6, pos.z);
        };

        crearBarril(new BABYLON.Vector3(11, 0, 11));
        crearBarril(new BABYLON.Vector3(11.5, 0, 12));

        // Mesa peque帽a
        const mesaTop = BABYLON.MeshBuilder.CreateBox(
          'mesaTop',
          { width: 1.5, height: 0.1, depth: 1 },
          scene
        );
        mesaTop.material = matMadera;
        mesaTop.position = new BABYLON.Vector3(16, 0.8, 11);

        const crearPataMesa = (x, z) => {
          const pata = BABYLON.MeshBuilder.CreateCylinder(
            'pataMesa',
            { height: 0.8, diameter: 0.1 },
            scene
          );
          pata.material = matMadera;
          pata.position = new BABYLON.Vector3(16 + x, 0.4, 11 + z);
        };
        crearPataMesa(-0.6, -0.4);
        crearPataMesa(0.6, -0.4);
        crearPataMesa(-0.6, 0.4);
        crearPataMesa(0.6, 0.4);

        // Columnas decorativas
        const crearColumna = (pos) => {
          const columna = BABYLON.MeshBuilder.CreateCylinder(
            'columna',
            { height: 4, diameterTop: 0.5, diameterBottom: 0.6 },
            scene
          );
          columna.material = matPiedraOscura;
          columna.position = new BABYLON.Vector3(pos.x, 2, pos.z);

          const capitel = BABYLON.MeshBuilder.CreateBox(
            'capitel',
            { width: 0.8, height: 0.3, depth: 0.8 },
            scene
          );
          capitel.material = matPiedraOscura;
          capitel.position = new BABYLON.Vector3(pos.x, 4.2, pos.z);
        };

        crearColumna(new BABYLON.Vector3(-5, 0, -5));
        crearColumna(new BABYLON.Vector3(5, 0, -5));

        // Cerca decorativa
        const crearCerca = (pos) => {
          for (let i = 0; i < 3; i++) {
            const poste = BABYLON.MeshBuilder.CreateCylinder(
              'poste',
              { height: 1.5, diameter: 0.1 },
              scene
            );
            poste.material = matMadera;
            poste.position = new BABYLON.Vector3(pos.x + i * 0.5, 0.75, pos.z);
          }

          const barra = BABYLON.MeshBuilder.CreateBox(
            'barra',
            { width: 1.5, height: 0.1, depth: 0.1 },
            scene
          );
          barra.material = matMadera;
          barra.position = new BABYLON.Vector3(pos.x + 0.5, 0.8, pos.z);
        };

        crearCerca(new BABYLON.Vector3(10, 0, 8));
        crearCerca(new BABYLON.Vector3(10, 0, 10));

        // Fogata
        const fogataBase = BABYLON.MeshBuilder.CreateCylinder(
          'fogataBase',
          { height: 0.2, diameter: 1 },
          scene
        );
        fogataBase.material = matPiedraOscura;
        fogataBase.position = new BABYLON.Vector3(14, 0.1, 12);

        const llama = BABYLON.MeshBuilder.CreateSphere(
          'llama',
          { diameter: 0.6 },
          scene
        );
        llama.material = matFuego;
        llama.position = new BABYLON.Vector3(14, 0.5, 12);

        // Animaci贸n de fuego
        scene.registerBeforeRender(() => {
          llama.scaling.y = 1 + Math.sin(Date.now() * 0.005) * 0.2;
        });

        // ============================================
        // CREAR MONEDAS DE ORO
        // ============================================
        const monedas = [];
        const posicionesMonedas = [
          new BABYLON.Vector3(13, 0.3, 13),
          new BABYLON.Vector3(17, 0.3, 15),
          new BABYLON.Vector3(15, 0.3, 17),
          new BABYLON.Vector3(19, 0.3, 13),
          new BABYLON.Vector3(14, 0.3, 19),
        ];

        for (let i = 0; i < TOTAL_MONEDAS; i++) {
          const moneda = BABYLON.MeshBuilder.CreateCylinder(
            `moneda${i}`,
            {
              height: 0.2,
              diameter: 0.8,
            },
            scene
          );
          moneda.material = matMoneda;
          moneda.position = posicionesMonedas[i].clone();
          moneda.metadata = { recogida: false, enCueva: false };
          monedas.push(moneda);

          // Animaci贸n de rotaci贸n
          scene.registerBeforeRender(function () {
            if (!moneda.metadata.recogida) {
              moneda.rotation.y += 0.02;
              moneda.position.y =
                posicionesMonedas[i].y + Math.sin(Date.now() * 0.003 + i) * 0.1;
            }
          });
        }

        // ============================================
        // MANEJO DE INPUT
        // ============================================
        scene.actionManager = new BABYLON.ActionManager(scene);

        scene.actionManager.registerAction(
          new BABYLON.ExecuteCodeAction(
            BABYLON.ActionManager.OnKeyDownTrigger,
            function (evt) {
              inputMap[evt.sourceEvent.key.toLowerCase()] = true;
            }
          )
        );

        scene.actionManager.registerAction(
          new BABYLON.ExecuteCodeAction(
            BABYLON.ActionManager.OnKeyUpTrigger,
            function (evt) {
              inputMap[evt.sourceEvent.key.toLowerCase()] = false;
            }
          )
        );

        // ============================================
        // LGICA DE RECOGER/DEJAR MONEDAS
        // ============================================
        scene.onKeyboardObservable.add((kbInfo) => {
          if (kbInfo.type === BABYLON.KeyboardEventTypes.KEYDOWN) {
            if (kbInfo.event.key === ' ') {
              // Verificar que el drag贸n est茅 cargado
              if (!dragon) return;

              // RECOGER MONEDA
              if (!monedaEnMano) {
                for (let moneda of monedas) {
                  if (!moneda.metadata.recogida && !moneda.metadata.enCueva) {
                    let dist = BABYLON.Vector3.Distance(
                      dragon.position,
                      moneda.position
                    );
                    if (dist < 3) {
                      console.log(' 隆Moneda recogida!');
                      moneda.parent = dragon;
                      moneda.position = new BABYLON.Vector3(0, 2, 0);
                      moneda.metadata.recogida = true;
                      monedaEnMano = true;
                      monedaActual = moneda;
                      actualizarUI();
                      break;
                    }
                  }
                }
              }
              // DEJAR MONEDA EN LA CUEVA
              else {
                let dist = BABYLON.Vector3.Distance(
                  dragon.position,
                  zonaEntrega.position
                );
                if (dist < 5) {
                  console.log(' 隆Moneda entregada en la cueva!');
                  monedaActual.parent = null;
                  monedaActual.position = new BABYLON.Vector3(
                    zonaEntrega.position.x + (Math.random() - 0.5) * 4,
                    0.3,
                    zonaEntrega.position.z + (Math.random() - 0.5) * 4
                  );
                  monedaActual.metadata.enCueva = true;
                  monedaEnMano = false;
                  monedasEntregadas++;
                  monedaActual = null;
                  actualizarUI();

                  // Verificar victoria
                  if (monedasEntregadas === TOTAL_MONEDAS) {
                    document.getElementById('victory-screen').style.display =
                      'block';
                  }
                }
              }
            }
          }
        });

        // ============================================
        // MOVIMIENTO DEL DRAGN
        // ============================================
        const velocidad = 0.15;
        scene.onBeforeRenderObservable.add(() => {
          // Verificar que el drag贸n est茅 cargado
          if (!dragon) return;

          let moved = false;
          let targetRotation = dragon.rotation.y;

          if (inputMap['w']) {
            dragon.position.z += velocidad;
            targetRotation = Math.PI; // Hacia adelante (+Z)
            moved = true;
          }
          if (inputMap['s']) {
            dragon.position.z -= velocidad;
            targetRotation = 0; // Hacia atr谩s (-Z)
            moved = true;
          }
          if (inputMap['a']) {
            dragon.position.x -= velocidad;
            targetRotation = Math.PI / 2; // Hacia la izquierda (-X)
            moved = true;
          }
          if (inputMap['d']) {
            dragon.position.x += velocidad;
            targetRotation = -Math.PI / 2; // Hacia la derecha (+X)
            moved = true;
          }

          // Rotaci贸n suave del drag贸n
          if (moved) {
            let diff = targetRotation - dragon.rotation.y;
            while (diff > Math.PI) diff -= 2 * Math.PI;
            while (diff < -Math.PI) diff += 2 * Math.PI;
            dragon.rotation.y += diff * 0.1;
          }

          // La c谩mara sigue al drag贸n
          camera.target = dragon.position;
        });

        return scene;
      };

      // ============================================
      // ACTUALIZAR UI
      // ============================================
      function actualizarUI() {
        document.getElementById('coins-delivered').textContent =
          monedasEntregadas;
        document.getElementById('total-coins').textContent = TOTAL_MONEDAS;

        const statusLight = document.getElementById('status-light');
        const statusText = document.getElementById('status-text');

        if (monedaEnMano) {
          statusLight.className = 'status-indicator status-carrying';
          statusText.textContent = 'Llevando moneda ';
        } else {
          statusLight.className = 'status-indicator status-empty';
          statusText.textContent = 'Sin moneda';
        }
      }

      // ============================================
      // INICIAR JUEGO
      // ============================================
      const scene = createScene();

      engine.runRenderLoop(function () {
        scene.render();
      });

      window.addEventListener('resize', function () {
        engine.resize();
      });

      // Inicializar UI
      actualizarUI();
    </script>
  </body>
</html>
